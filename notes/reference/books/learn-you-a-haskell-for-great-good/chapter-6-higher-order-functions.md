# Chapter 6: Higher Order Functions

## Curried functions

* Every function in Haskell takes only one param.
* Functions can take two params by return a "curried function", aka a **partially applied** function.
  * For example, ``max 4 5`` actually does the following:
    1. Creates a function that takes a parameter, returning 4 or that parameter.
    2. 5 is then applied to that parameter.
  * These calls are equivalent:

    ```
    > max 4 5
    > (max 4) 5
    ```

  * Type definition helps explain what's going on:

    ```
    max :: (Ord a) => a -> a -> a
    ```

    * ``max`` takes an ``a`` and returns a function that takes an ``a`` and returns an ``a``.

* Putting a space between two args is called **function application**.

* Can curry a function (returning a partially applied function) as follows:

  ```
  Prelude> let higherOr4 = max 4
  Prelude> higherOr4 7
  7
  Prelude> higherOr4 2
  4
  ```

* Infix functions are partially applied using **sections**.
  * Surround it with parenthesis and supply parameter to one side.
  
    ```
    divideBy5 :: (Floating a) => a -> a
    divideBy5 = (/5)
    ```
  * Behaviour of ``-`` needs to be considered with sections. ``(-4)`` doesn't subtract 4, it means negative 4. Instead use ``(subtract 4)``.

## Higher-orderism

* Apply twice example.

  * takes in a function and a value
  * return a function with a single argument
  * argument is said function applied to said argument

    ```
    applyTwice :: (a -> a) -> a -> a
    applyTwice f x = f (f x)
    ```

  * Using it with an prefix function:

    ```
    > let add3 x = x + 3
    > applyTwice add3 3
    9
    ```

  * Same, but in Python:

    ```
    >>> def apply_twice(func, x):
            return func( func(x) )
    >>> apply_twice(lambda x: x + 2, 2)
    >>> # expected result: 6
    >>> 6 
    ```

* zipWith example.

  * First parameter is a function that takes two things and returns a third.
  * Second and third param is a list.
  * List returned.
  * Handles empty list cases.
  * Applies function to first element of both lists, and appends (?) it to another list, generated by passing the rest of the lists into the same function.

    ```
    zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
    zipWith' _ [] _ = []
    zipWith' _ _ [] = []
    zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
    ```

    * Same in Python:

      ```
      >>> def zipWith(f, a, b):
      ...     if not any([a, b]):
      ...         return []
      ...     else:
      ...         return [f(a[0], b[0])] + zipWith(f, a[1:], b[1:])
      ...
      >>> zipWith(lambda x, y: x + y, [1,2,3], [4,5,6])
      [5, 7, 9]
      ```

##  Maps and filters

* ```map``` takes a function and applies it to every element in a list, to produce a new list.

  ```
  map :: a -> [b] -> [b] 
  map f (x:xs) = f(x) : map f xs
  ```

  * In Python:

    ```
    def map(func, l):
        return [func(l[0])] + map(func, l[1:]) if l else []
    ```

* ``filter`` takes a predicate (a function that tells whether something is ``true`` or not)

  ```
  filter :: (a -> Bool) -> [a] -> [a]
  filter _ [] = []
  filter p (x:xs)
      | p x       = x : filter p xs
      | otherwise = filter p xs
  ```

## Lambdas

* Anonymous functions, generally used to pass into higher-order functions.
* Prepend with ``\``


### Exercises

* Summarize chapter.
* Create a function that compares 2 numbers, specify the argument, then without. Why do they both work?
